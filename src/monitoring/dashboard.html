<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MPEG-DASH Enhanced Monitor</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .header {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .container-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .container-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-left: 4px solid #007acc;
        }
        .container-name {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-running { background-color: #28a745; }
        .status-stopped { background-color: #dc3545; }
        .metric {
            display: flex;
            justify-content: space-between;
            margin: 12px 0;
            padding: 8px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        .metric-label {
            font-weight: 500;
            color: #495057;
        }
        .metric-value {
            font-weight: bold;
            color: #212529;
        }
        .metric-percent {
            color: #007acc;
        }
        .metric-danger { color: #dc3545; }
        .metric-warning { color: #ffc107; }
        .metric-success { color: #28a745; }
        .refresh-btn {
            background: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
        }
        .refresh-btn:hover {
            background: #0056b3;
        }
        .api-status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
            text-align: center;
        }
        .api-status.success { background: #d4edda; color: #155724; }
        .api-status.error { background: #f8d7da; color: #721c24; }
        .api-status.simulated { background: #fff3cd; color: #856404; }
        .charts-container {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .chart-wrapper {
            flex: 1;
            background: #f8f9fa;
            border-radius: 4px;
            padding: 10px;
            text-align: center;
        }
        .chart-title {
            font-size: 12px;
            font-weight: bold;
            color: #495057;
            margin-bottom: 5px;
        }
        .chart-canvas {
            max-height: 80px;
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>📊 MPEG-DASH Enhanced Monitor</h1>
        <p style="margin: 5px 0; color: #666; font-size: 14px;">Real-time container metrics: Memory & IO (Absolute + Relative)</p>
        <button class="refresh-btn" onclick="refreshData()">🔄 Refresh Data</button>
    </div>

    <div class="container-grid" id="containerGrid">
        <!-- Container cards will be populated by JavaScript -->
    </div>

    <script>
        const containers = [
            { name: 'load-balancer', type: 'load-balancer' },
            { name: 'mpeg-dash-processor-1', type: 'processor' },
            { name: 'mpeg-dash-processor-2', type: 'processor' },
            { name: 'mpeg-dash-processor-3', type: 'processor' },
            { name: 'mpeg-dash-processor-4', type: 'processor' },
            { name: 'mpeg-dash-processor-5', type: 'processor' },
            { name: 'mpeg-dash-processor-6', type: 'processor' },
            { name: 'mpeg-dash-processor-7', type: 'processor' },
            { name: 'mpeg-dash-processor-8', type: 'processor' }
        ];

        // Data storage for charts - stores historical data for each container
        const chartData = {};
        const MAX_DATA_POINTS = 20; // Keep last 20 data points
        const chartInstances = {}; // Store chart instances
        
        // Storage for previous metrics to calculate deltas
        const previousMetrics = {};
        const ioRateCache = {}; // Cache recent IO rates
        
        function calculateIORate(containerName, currentIOBytes, currentTimestamp) {
            let ioMbps = 0;
            
            if (previousMetrics[containerName]) {
                const prev = previousMetrics[containerName];
                const timeDiff = currentTimestamp - prev.timestamp;
                
                if (timeDiff > 0) {
                    const bytesDiff = currentIOBytes - prev.ioBytes;
                    if (bytesDiff > 0) { // Only calculate if there's actual IO activity
                        ioMbps = (bytesDiff / (1024 * 1024)) / timeDiff; // Convert to MBps
                        
                        // Cache the calculated rate with timestamp
                        ioRateCache[containerName] = {
                            rate: ioMbps,
                            calculatedAt: currentTimestamp
                        };
                        
                        console.log(`${containerName}: New IO activity - ${bytesDiff} bytes in ${timeDiff.toFixed(2)}s = ${ioMbps.toFixed(2)} MB/s`);
                    } else if (bytesDiff === 0) {
                        // No new IO activity, check if we have a recent cached rate
                        if (ioRateCache[containerName]) {
                            const cached = ioRateCache[containerName];
                            const cacheAge = currentTimestamp - cached.calculatedAt;
                            
                            // Use cached rate if it's less than 3 seconds old
                            if (cacheAge < 3) {
                                ioMbps = cached.rate * Math.max(0, (3 - cacheAge) / 3); // Decay over time
                                console.log(`${containerName}: Using cached rate (${cacheAge.toFixed(1)}s old): ${ioMbps.toFixed(2)} MB/s`);
                            } else {
                                // Clear old cache
                                delete ioRateCache[containerName];
                                console.log(`${containerName}: Cache expired, rate = 0`);
                            }
                        }
                    }
                }
            }
            
            // Store current values for next calculation
            previousMetrics[containerName] = {
                ioBytes: currentIOBytes,
                timestamp: currentTimestamp
            };
            
            return ioMbps;
        }

        function calculateIOPercent(ioMbps, limitMbps) {
            if (limitMbps > 0) {
                return Math.min(100, (ioMbps / limitMbps) * 100);
            }
            return 0;
        }

        function createContainerCard(container) {
            const isLoadBalancer = container.type === 'load-balancer';
            const cardClass = isLoadBalancer ? 'container-card load-balancer' : 'container-card';
            
            return `
                <div class="${cardClass}" id="card-${container.name}">
                    <div class="container-name">
                        <span class="status-indicator" id="status-${container.name}"></span>
                        ${container.name}
                    </div>
                    <div class="metric">
                        <span class="metric-label">Memory Usage:</span>
                        <span class="metric-value" id="memory-absolute-${container.name}">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Memory %:</span>
                        <span class="metric-value metric-percent" id="memory-percent-${container.name}">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">IO Rate:</span>
                        <span class="metric-value" id="disk-read-absolute-${container.name}">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">IO %:</span>
                        <span class="metric-value metric-percent" id="disk-read-percent-${container.name}">-</span>
                    </div>
                    <div class="charts-container">
                        <div class="chart-wrapper">
                            <div class="chart-title">Memory %</div>
                            <canvas id="memory-chart-${container.name}" class="chart-canvas"></canvas>
                        </div>
                        <div class="chart-wrapper">
                            <div class="chart-title">Disk I/O %</div>
                            <canvas id="disk-chart-${container.name}" class="chart-canvas"></canvas>
                        </div>
                    </div>
                </div>
            `;
        }

        async function fetchMetrics() {
            let statusDiv = document.getElementById('api-status');
            if (!statusDiv) {
                statusDiv = createStatusDiv();
            }
            
            try {
                console.log('Fetching metrics from API...');
                const response = await fetch('http://localhost:3002/metrics', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Received API response:', data);
                    console.log('Response has timestamp:', !!data.timestamp);
                    console.log('Response has containers:', !!data.containers);
                    if (data.containers) {
                        console.log('Number of containers:', data.containers.length);
                        console.log('First container sample:', data.containers[0]);
                    }
                    
                    if (data.error) {
                        statusDiv.textContent = `⚠️ API Error: ${data.error}`;
                        statusDiv.className = 'api-status error';
                        console.error('API returned error:', data.error);
                        return;
                    }
                    
                    if (data.containers && data.containers.length > 0) {
                        const updateTime = new Date().toLocaleTimeString();
                        statusDiv.textContent = `✅ Live data (${data.containers.length} containers) - ${updateTime}`;
                        statusDiv.className = 'api-status success';
                        
                        data.containers.forEach((container, index) => {
                            console.log(`Processing container ${index}:`, container.name, container.metrics);
                            updateContainerCard(container);
                        });
                        return;
                    } else {
                        console.warn('API response has no containers or empty container list');
                        statusDiv.textContent = '⚠️ API returned no container data';
                        statusDiv.className = 'api-status error';
                        return;
                    }
                }
                
                // Fallback to simulated data if server is not available
                console.log('Metrics server not available, using simulated data');
                statusDiv.textContent = '🎭 Using simulated data (API unavailable)';
                statusDiv.className = 'api-status simulated';
                
                const data = await simulateMetricsEndpoint();
                if (data.containers) {
                    data.containers.forEach(container => {
                        updateContainerCard(container);
                    });
                }
            } catch (error) {
                console.error('Error fetching metrics:', error);
                
                statusDiv.textContent = `⚠️ Connection issue - ${new Date().toLocaleTimeString()}`;
                statusDiv.className = 'api-status error';
            } finally {
                // Schedule next update after current one completes
                setTimeout(fetchMetrics, 1000); // Update every second
            }
        }
        
        function createStatusDiv() {
            const statusDiv = document.createElement('div');
            statusDiv.id = 'api-status';
            statusDiv.className = 'api-status';
            
            const header = document.querySelector('.header');
            header.appendChild(statusDiv);
            
            return statusDiv;
        }

        function initializeChart(canvasId, label, color) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return null;
            
            return new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: label,
                        data: [],
                        borderColor: color,
                        backgroundColor: color + '20',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            display: false,
                            min: 0,
                            max: 100
                        }
                    },
                    elements: {
                        line: {
                            borderWidth: 2
                        }
                    }
                }
            });
        }

        function initializeContainerCharts(containerName) {
            // Initialize data storage for this container
            chartData[containerName] = {
                memory: [],
                disk: [],
                timestamps: []
            };
            
            // Initialize charts
            chartInstances[containerName] = {
                memory: initializeChart(`memory-chart-${containerName}`, 'Memory %', '#007acc'),
                disk: initializeChart(`disk-chart-${containerName}`, 'Disk I/O %', '#28a745')
            };
        }

        function updateContainerCard(containerData) {
            const name = containerData.name;
            
            // Debug logging for new metrics structure
            if (containerData.metrics) {
                console.log(`${name}:`, {
                    memory_absolute: containerData.metrics.memory?.absolute,
                    memory_relative: containerData.metrics.memory?.relative,
                    io_absolute: containerData.metrics.io?.absolute,
                    io_relative: containerData.metrics.io?.relative
                });
            }
            
            // Update status indicator
            const statusEl = document.getElementById(`status-${name}`);
            if (statusEl) {
                statusEl.className = `status-indicator ${containerData.status === 'running' ? 'status-running' : 'status-stopped'}`;
            }
            
            if (containerData.status !== 'running') {
                // Container is stopped, clear metrics
                document.getElementById(`memory-absolute-${name}`).textContent = 'Stopped';
                document.getElementById(`memory-percent-${name}`).textContent = '-';
                document.getElementById(`disk-read-absolute-${name}`).textContent = '-';
                document.getElementById(`disk-read-percent-${name}`).textContent = '-';
                return;
            }
            
            // Update metrics using new API structure with frontend delta calculation
            const metrics = containerData.metrics;
            if (metrics) {
                try {
                    // 1. Memory Absolute
                    const memAbsoluteEl = document.getElementById(`memory-absolute-${name}`);
                    if (memAbsoluteEl) {
                        const memHuman = metrics.memory?.absolute?.human || 'N/A';
                        memAbsoluteEl.textContent = memHuman;
                    }
                    
                    // 2. Memory Percentage
                    const memPercentEl = document.getElementById(`memory-percent-${name}`);
                    const memPercent = metrics.memory?.relative?.percent || 0;
                    const memLimitMb = metrics.memory?.relative?.limit_mb || 0;
                    if (memPercentEl) {
                        memPercentEl.textContent = memLimitMb > 0 ? `${memPercent}% (${memLimitMb}MB limit)` : `${memPercent}%`;
                        
                        // Color code memory percentage
                        if (memPercent > 85) {
                            memPercentEl.className = 'metric-value metric-percent metric-danger';
                        } else if (memPercent > 70) {
                            memPercentEl.className = 'metric-value metric-percent metric-warning';
                        } else {
                            memPercentEl.className = 'metric-value metric-percent metric-success';
                        }
                    }
                    
                    // 3. IO Rate Calculation (Frontend Delta)
                    const currentIOBytes = metrics.io?.absolute?.bytes_total || 0;
                    const currentTimestamp = metrics.last_updated || containerData.timestamp;
                    const ioMbps = calculateIORate(name, currentIOBytes, currentTimestamp);
                    
                    // Display IO Rate Absolute
                    const diskReadAbsoluteEl = document.getElementById(`disk-read-absolute-${name}`);
                    if (diskReadAbsoluteEl) {
                        diskReadAbsoluteEl.textContent = `${ioMbps.toFixed(2)} MB/s`;
                    }
                    
                    // 4. IO Rate Percentage
                    const ioLimitMbps = metrics.io?.relative?.limit_mbps || 0;
                    const ioPercent = calculateIOPercent(ioMbps, ioLimitMbps);
                    const diskReadPercentEl = document.getElementById(`disk-read-percent-${name}`);
                    if (diskReadPercentEl) {
                        diskReadPercentEl.textContent = ioLimitMbps > 0 ? `${ioPercent.toFixed(1)}% (${ioLimitMbps}MB/s limit)` : `${ioPercent.toFixed(1)}%`;
                        
                        // Color code disk read percentage
                        if (ioPercent > 80) {
                            diskReadPercentEl.className = 'metric-value metric-percent metric-danger';
                        } else if (ioPercent > 50) {
                            diskReadPercentEl.className = 'metric-value metric-percent metric-warning';
                        } else {
                            diskReadPercentEl.className = 'metric-value metric-percent metric-success';
                        }
                    }
                    
                    // Update chart data
                    updateChartData(name, memPercent, ioPercent);
                    
                    // Debug logging
                    console.log(`${name}: Raw bytes=${currentIOBytes}, IO Rate=${ioMbps.toFixed(2)} MB/s (${ioPercent.toFixed(1)}%), Timestamp=${currentTimestamp}`);
                    if (ioMbps > 0.1) { // Only log significant IO activity
                        console.log(`${name}: 🔥 Significant IO activity detected!`);
                    }
                    
                } catch (error) {
                    console.error(`Error updating container card for ${name}:`, error);
                    console.log('Container data:', containerData);
                    console.log('Metrics:', metrics);
                }
            } else {
                console.warn(`No metrics found for container ${name}`);
                // Set fallback values
                const elements = [
                    `memory-absolute-${name}`,
                    `memory-percent-${name}`,
                    `disk-read-absolute-${name}`,
                    `disk-read-percent-${name}`
                ];
                elements.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = 'No data';
                });
            }
        }

        function updateChartData(containerName, memoryPercent, diskPercent) {
            // Initialize chart data if it doesn't exist
            if (!chartData[containerName]) {
                initializeContainerCharts(containerName);
            }
            
            const data = chartData[containerName];
            const currentTime = new Date().toLocaleTimeString();
            
            // Add new data points
            data.memory.push(memoryPercent);
            data.disk.push(diskPercent);
            data.timestamps.push(currentTime);
            
            // Keep only the last MAX_DATA_POINTS
            if (data.memory.length > MAX_DATA_POINTS) {
                data.memory.shift();
                data.disk.shift();
                data.timestamps.shift();
            }
            
            // Update charts
            const charts = chartInstances[containerName];
            if (charts && charts.memory && charts.disk) {
                // Update memory chart
                charts.memory.data.labels = data.timestamps;
                charts.memory.data.datasets[0].data = data.memory;
                charts.memory.update('none'); // No animation for smoother updates
                
                // Update disk chart
                charts.disk.data.labels = data.timestamps;
                charts.disk.data.datasets[0].data = data.disk;
                charts.disk.update('none'); // No animation for smoother updates
            }
        }

        async function simulateMetricsEndpoint() {
            // Simulated data for when API is unavailable - matching new API format
            const containerConfigs = [
                { name: 'mpeg-dash-processor-1', memLimit: 2048, ioLimit: 1024 },
                { name: 'mpeg-dash-processor-2', memLimit: 1024, ioLimit: 512 },
                { name: 'mpeg-dash-processor-3', memLimit: 512, ioLimit: 256 },
                { name: 'mpeg-dash-processor-4', memLimit: 256, ioLimit: 128 },
                { name: 'mpeg-dash-processor-5', memLimit: 128, ioLimit: 64 },
                { name: 'mpeg-dash-processor-6', memLimit: 64, ioLimit: 32 },
                { name: 'mpeg-dash-processor-7', memLimit: 32, ioLimit: 16 },
                { name: 'mpeg-dash-processor-8', memLimit: 16, ioLimit: 8 }
            ];
            
            return {
                timestamp: Math.floor(Date.now() / 1000),
                update_interval_ms: 500,
                containers: containerConfigs.map(config => {
                    const memBytes = Math.floor(Math.random() * (config.memLimit * 0.8 * 1024 * 1024) + (config.memLimit * 0.1 * 1024 * 1024));
                    const memPercent = Math.floor(Math.random() * 80 + 10);
                    const ioMbps = Math.random() * (config.ioLimit * 0.6) + (config.ioLimit * 0.05);
                    const ioPercent = Math.floor(Math.random() * 60 + 5);
                    
                    return {
                        name: config.name,
                        status: 'running',
                        timestamp: Math.floor(Date.now() / 1000),
                        metrics: {
                            memory: {
                                absolute: {
                                    bytes: memBytes,
                                    human: `${Math.floor(memBytes / 1024 / 1024)}MB`
                                },
                                relative: {
                                    percent: memPercent,
                                    limit_mb: config.memLimit
                                }
                            },
                            io: {
                                absolute: {
                                    bytes_total: Math.floor(Math.random() * 1000000000 + 100000000), // Random total bytes
                                    human: `${Math.floor(Math.random() * 500 + 50)}MB`
                                },
                                relative: {
                                    limit_mbps: config.ioLimit
                                }
                            },
                            last_updated: Date.now() / 1000
                        }
                    };
                })
            };
        }

        function refreshData() {
            fetchMetrics();
        }

        // Initialize dashboard
        function initDashboard() {
            const grid = document.getElementById('containerGrid');
            grid.innerHTML = containers.map(createContainerCard).join('');
            
            // Initialize charts for all containers
            containers.forEach(container => {
                initializeContainerCharts(container.name);
            });
            
            // Start periodic updates (no setInterval needed, fetchMetrics handles its own scheduling)
            fetchMetrics();
        }

        // Start the dashboard when page loads
        document.addEventListener('DOMContentLoaded', initDashboard);
    </script>
</body>
</html>